<?php

$web = '/public/index.php';

if (\in_array('phar', stream_get_wrappers()) && class_exists(\Phar::class, 0)) {
    \Phar::interceptFileFuncs();
    set_include_path('phar://'.__FILE__.\PATH_SEPARATOR.get_include_path());
    \Phar::webPhar(null, $web);

    include 'phar://'.__FILE__.'/'.\Extract_Phar::START;

    return;
}

if ((isset($_SERVER['REQUEST_URI'], $_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {
    \Extract_Phar::go(true);
    $mimes = [
        'phps' => 2,
        'c' => 'text/plain',
        'cc' => 'text/plain',
        'cpp' => 'text/plain',
        'c++' => 'text/plain',
        'dtd' => 'text/plain',
        'h' => 'text/plain',
        'log' => 'text/plain',
        'rng' => 'text/plain',
        'txt' => 'text/plain',
        'xsd' => 'text/plain',
        'php' => 1,
        'inc' => 1,
        'avi' => 'video/avi',
        'bmp' => 'image/bmp',
        'css' => 'text/css',
        'gif' => 'image/gif',
        'htm' => 'text/html',
        'html' => 'text/html',
        'htmls' => 'text/html',
        'ico' => 'image/x-ico',
        'jpe' => 'image/jpeg',
        'jpg' => 'image/jpeg',
        'jpeg' => 'image/jpeg',
        'js' => 'application/x-javascript',
        'midi' => 'audio/midi',
        'mid' => 'audio/midi',
        'mod' => 'audio/mod',
        'mov' => 'movie/quicktime',
        'mp3' => 'audio/mp3',
        'mpg' => 'video/mpeg',
        'mpeg' => 'video/mpeg',
        'pdf' => 'application/pdf',
        'png' => 'image/png',
        'swf' => 'application/shockwave-flash',
        'tif' => 'image/tiff',
        'tiff' => 'image/tiff',
        'wav' => 'audio/wav',
        'xbm' => 'image/xbm',
        'xml' => 'text/xml',
    ];

    header('Cache-Control: no-cache, must-revalidate');
    header('Pragma: no-cache');

    $basename = basename(__FILE__);

    if (!strpos($_SERVER['REQUEST_URI'], $basename)) {
        chdir(\Extract_Phar::$temp);

        include $web;

        return;
    }
    $pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + \strlen($basename));

    if (!$pt || $pt == '/') {
        $pt = $web;
        header('HTTP/1.1 301 Moved Permanently');
        header('Location: '.$_SERVER['REQUEST_URI'].'/'.$pt);

        exit;
    }
    $a = realpath(\Extract_Phar::$temp.\DIRECTORY_SEPARATOR.$pt);

    if (!$a || \strlen(\dirname($a)) < \strlen(\Extract_Phar::$temp)) {
        header('HTTP/1.0 404 Not Found');
        echo "<html>\n <head>\n  <title>File Not Found<title>\n </head>\n <body>\n  <h1>404 - File Not Found</h1>\n </body>\n</html>";

        exit;
    }
    $b = pathinfo($a);

    if (!isset($b['extension'])) {
        header('Content-Type: text/plain');
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }

    if (isset($mimes[$b['extension']])) {
        if ($mimes[$b['extension']] === 1) {
            include $a;

            exit;
        }

        if ($mimes[$b['extension']] === 2) {
            highlight_file($a);

            exit;
        }
        header('Content-Type: '.$mimes[$b['extension']]);
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }
}

final class Extract_Phar {
    public const GZ = 0x10_00;
    public const BZ2 = 0x20_00;
    public const MASK = 0x30_00;
    public const START = '/public/console.php';
    public const LEN = 6_661;
    public static $temp;
    public static $origdir;

    public static function go($return = false): void {
        $fp = fopen(__FILE__, 'rb');
        fseek($fp, self::LEN);
        $L = unpack('V', $a = fread($fp, 4));
        $m = '';

        do {
            $read = 8_192;

            if ($L[1] - \strlen($m) < 8_192) {
                $read = $L[1] - \strlen($m);
            }
            $last = fread($fp, $read);
            $m .= $last;
        } while (\strlen($last) && \strlen($m) < $L[1]);

        if (\strlen($m) < $L[1]) {
            exit('ERROR: manifest length read was "'
            .\strlen($m).'" should be "'
            .$L[1].'"');
        }

        $info = self::_unpack($m);
        $f = $info['c'];

        if ($f & self::GZ) {
            if (!\function_exists('gzinflate')) {
                exit('Error: zlib extension is not enabled -'
                .' gzinflate() function needed for zlib-compressed .phars');
            }
        }

        if ($f & self::BZ2) {
            if (!\function_exists('bzdecompress')) {
                exit('Error: bzip2 extension is not enabled -'
                .' bzdecompress() function needed for bz2-compressed .phars');
            }
        }

        $temp = self::tmpdir();

        if (!$temp || !is_writable($temp)) {
            $sessionpath = session_save_path();

            if (str_contains($sessionpath, ';'))
                $sessionpath = substr($sessionpath, strpos($sessionpath, ';') + 1);

            if (!file_exists($sessionpath) || !is_dir($sessionpath)) {
                exit('Could not locate temporary directory to extract phar');
            }
            $temp = $sessionpath;
        }

        $temp .= '/pharextract/'.basename(__FILE__, '.phar');
        self::$temp = $temp;
        self::$origdir = getcwd();
        mkdir($temp, 0o777, true);
        $temp = realpath($temp);

        if (!file_exists($temp.\DIRECTORY_SEPARATOR.md5_file(__FILE__))) {
            self::_removeTmpFiles($temp, getcwd());
            mkdir($temp, 0o777, true);
            file_put_contents($temp.'/'.md5_file(__FILE__), '');

            foreach ($info['m'] as $path => $file) {
                $a = !file_exists(\dirname($temp.'/'.$path));
                mkdir(\dirname($temp.'/'.$path), 0o777, true);
                clearstatcache();

                if ($path[\strlen($path) - 1] == '/') {
                    mkdir($temp.'/'.$path, 0o777);
                } else {
                    file_put_contents($temp.'/'.$path, self::extractFile($path, $file, $fp));
                    chmod($temp.'/'.$path, 0o666);
                }
            }
        }

        chdir($temp);

        if (!$return) {
            include self::START;
        }
    }

    public static function tmpdir() {
        if (str_contains(\PHP_OS, 'WIN')) {
            if ($var = getenv('TMP') ?: getenv('TEMP')) {
                return $var;
            }

            if (is_dir('/temp') || mkdir('/temp')) {
                return realpath('/temp');
            }

            return false;
        }

        if ($var = getenv('TMPDIR')) {
            return $var;
        }

        return realpath('/tmp');
    }

    public static function _unpack($m) {
        $info = unpack('V', substr($m, 0, 4));
        $l = unpack('V', substr($m, 10, 4));
        $m = substr($m, 14 + $l[1]);
        $s = unpack('V', substr($m, 0, 4));
        $o = 0;
        $start = 4 + $s[1];
        $ret['c'] = 0;

        for ($i = 0; $i < $info[1]; $i++) {
            $len = unpack('V', substr($m, $start, 4));
            $start += 4;
            $savepath = substr($m, $start, $len[1]);
            $start += $len[1];
            $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));
            $ret['m'][$savepath][3] = \sprintf('%u', $ret['m'][$savepath][3]
            & 0xFF_FF_FF_FF);
            $ret['m'][$savepath][7] = $o;
            $o += $ret['m'][$savepath][2];
            $start += 24 + $ret['m'][$savepath][5];
            $ret['c'] |= $ret['m'][$savepath][4] & self::MASK;
        }

        return $ret;
    }

    public static function extractFile($path, $entry, $fp) {
        $data = '';
        $c = $entry[2];

        while ($c) {
            if ($c < 8_192) {
                $data .= fread($fp, $c);
                $c = 0;
            } else {
                $c -= 8_192;
                $data .= fread($fp, 8_192);
            }
        }

        if ($entry[4] & self::GZ) {
            $data = gzinflate($data);
        } elseif ($entry[4] & self::BZ2) {
            $data = bzdecompress($data);
        }

        if (\strlen($data) != $entry[0]) {
            exit('Invalid internal .phar file (size error '.\strlen($data).' != '
            .$stat[7].')');
        }

        if ($entry[3] != \sprintf('%u', crc32($data) & 0xFF_FF_FF_FF)) {
            exit('Invalid internal .phar file (checksum error)');
        }

        return $data;
    }

    public static function _removeTmpFiles($temp, $origdir): void {
        chdir($temp);

        foreach (glob('*') as $f) {
            if (file_exists($f)) {
                is_dir($f) ? rmdir($f) : unlink($f);

                if (file_exists($f) && is_dir($f)) {
                    self::_removeTmpFiles($f, getcwd());
                }
            }
        }

        rmdir($temp);
        clearstatcache();
        chdir($origdir);
    }
}

\Extract_Phar::go();
__HALT_COMPILER(); ?>
G                 &   components/error/firehub.Exception.php'  ó<7g'  ÆÆŒc∂      '   components/error/firehub.Exception.php~  ó<7g  £∂Ê∂         public/console.php›  ó<7g›  ¿˙0ø∂         public/index.php‹  ó<7g‹  \⁄}5∂      H   support/lowlevel/exceptions/arr/firehub.ArrSizeInconsistentException.phpY  ó<7gY  'I)n∂      I   support/lowlevel/exceptions/arr/firehub.FailedSortMultiArrayException.phpZ  ó<7gZ  î√∂      J   support/lowlevel/exceptions/arr/firehub.FailedSortMultiArrayException.php~Y  ó<7gY  'I)n∂      J   support/lowlevel/exceptions/autoload/firehub.AutoloadRegisterException.phpq  ó<7gq  áÃª∞∂      K   support/lowlevel/exceptions/autoload/firehub.AutoloadRegisterException.php~0  ó<7g0  ¶ÆÚ±∂      G   support/lowlevel/exceptions/autoload/firehub.ClassNotFoundException.phpl  ó<7gl  zkÃò∂      4   support/lowlevel/exceptions/firehub.ArrException.php4  ó<7g4  â·ÿï∂      9   support/lowlevel/exceptions/firehub.AutoloadException.php<  ó<7g<  ä’í
∂      :   support/lowlevel/exceptions/firehub.AutoloadException.php~;  ó<7g;  îŸø∂      B   support/lowlevel/exceptions/firehub.AutoloadRegisterException.php~7  ó<7g7  eˇ°∂      ?   support/lowlevel/exceptions/firehub.ClassNotFoundException.php~(  ó<7g(  ®›£Ê∂          support/lowlevel/firehub.Arr.phpä  ó<7gä  j%§∂      !   support/lowlevel/firehub.Arr.php~‘  ó<7g‘  Ã”€∞∂      (   support/lowlevel/firehub.SplAutoload.php  ó<7g  ÀKœÑ∂      )   support/lowlevel/firehub.SplAutoload.php~Á  ó<7gÁ  uÎ:∂      %   testing/phpmd/BooleanArgumentFlag.php  ó<7g  ´`(m∂      <?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Components
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Components\Error;

use Exception as InternalException;

/**
 * ### Main Exception
 * @since 1.0.0
 */
class Exception extends InternalException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Components
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Components\Error;

use Exception;

/**
 * ### Main Exception
 * @since 1.0.0
 */
class AutoloadException extends Exception {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * This is a landing file if the PHAR archive is accessed through a command-line.
 * @since 1.0.0
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Public
 *
 * @version GIT: $Id$ Blob checksum.
 */<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * This is a landing file if the PHAR archive is accessed through a web browser.
 * @since 1.0.0
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Public
 *
 * @version GIT: $Id$ Blob checksum.
 */<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Arr;

use FireHub\Core\Support\LowLevel\Exceptions\ArrException;

/**
 * ### Array Exception
 * @since 1.0.0
 */
class ArrSizeInconsistentException extends ArrException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Arr;

use FireHub\Core\Support\LowLevel\Exceptions\ArrException;

/**
 * ### Array Exception
 * @since 1.0.0
 */
class FailedSortMultiArrayException extends ArrException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Arr;

use FireHub\Core\Support\LowLevel\Exceptions\ArrException;

/**
 * ### Array Exception
 * @since 1.0.0
 */
class ArrSizeInconsistentException extends ArrException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Autoload;

use FireHub\Core\Support\LowLevel\Exceptions\AutoloadException;

/**
 * ### Autoload Register Exception
 * @since 1.0.0
 */
class AutoloadRegisterException extends AutoloadException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Autoload;

/**
 * ### Autoload Register Exception
 * @since 1.0.0
 */
class AutoloadRegisterException extends AutoloadException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions\Autoload;

use FireHub\Core\Support\LowLevel\Exceptions\AutoloadException;

/**
 * ### Class not found exception
 * @since 1.0.0
 */
class ClassNotFoundException extends AutoloadException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions;

use FireHub\Core\Components\Error\Exception;

/**
 * ### Array Exception
 * @since 1.0.0
 */
class ArrException extends Exception {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions;

use FireHub\Core\Components\Error\Exception;

/**
 * ### Autoload Exception
 * @since 1.0.0
 */
class AutoloadException extends Exception {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\\Autoload;

use FireHub\Core\Components\Error\Exception;

/**
 * ### Autoload Exception
 * @since 1.0.0
 */
class AutoloadException extends Exception {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions;

use Exception;

/**
 * ### Autoload Register Exception
 * @since 1.0.0
 */
class AutoloadRegisterException extends AutoloadException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel\Exceptions;

/**
 * ### Class not found exception
 * @since 1.0.0
 */
final class ClassNotFoundException extends AutoloadException {}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel;

use FireHub\Core\Support\LowLevel\Exceptions\Arr\ {
    ArrSizeInconsistentException, FailedSortMultiArrayException
};
use ArgumentCountError, ValueError;

use function array_is_list;
use function array_key_exists;
use function array_multisort;
use function in_array;

/**
 * ### Array low-level proxy class
 * @since 1.0.0
 *
 * @internal
 */
final class Arr {

    /**
     * ### Checks if the given key or index exists in the array
     *
     * Returns true if the given key is set in the array. Key can be any value possible for an array index.
     * @since 1.0.0
     *
     * @param array-key $key <p>
     * Key to check.
     * </p>
     * @param array<array-key, mixed> $array <p>
     * An array with keys to check.
     * </p>
     *
     * @return bool True if the key exists in an array, false otherwise.
     *
     * @note Method will search for the keys in the first dimension only. Nested keys in multidimensional arrays will
     * not be found.
     */
    public static function keyExist (int|string $key, array $array):bool {

        return array_key_exists($key, $array);

    }

    /**
     * ### Checks if a value exists in an array
     * @since 1.0.0
     *
     * @param mixed $value <p>
     * The searched value.
     * note: If a needle is a string, the comparison is done in a case-sensitive manner.
     * </p>
     * @param array<array-key, mixed> $array <p>
     * The array.
     * </p>
     *
     * @return bool True if a value is found in the array, false otherwise.
     */
    public static function inArray (mixed $value, array $array):bool {

        return in_array($value, $array, true);

    }

    /**
     * ### Checks whether a given array is a list
     *
     * Determines if the given array is a list. An array is considered a list if its keys consist of consecutive
     * numbers from 0 to count($array)-1.
     * @since 1.0.0
     *
     * @param array<array-key, mixed> $array <p>
     * The array is being evaluated.
     * </p>
     *
     * @return ($array is list ? true: false) True if an array is a list, false otherwise.
     *
     * @note This function returns true on empty arrays.
     */
    public static function isList (array $array):bool {

        return array_is_list($array);

    }

    /**
     * ### Sort multiple on multidimensional arrays
     * @since 1.0.0
     *
     * @param array<array-key, array<array-key, mixed>> $array <p>
     * A multidimensional array being sorted.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Arr\FailedSortMultiArrayException Failed to sort a multi-sort array.
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Arr\ArrSizeInconsistentException If array sizes are inconsistent.
     *
     * @return bool True on success.
     *
     * @caution Associative (string) keys will be maintained, but numeric keys will be re-indexed.
     * @note Resets array's internal pointer to the first element.
     *
     * @phpstan-ignore return.phpDocType (PHPStan reports that the method could still return bool)
     */
    public static function multiSort (array $array):true {

        try {

            return array_multisort(...$array)
                ?: throw new FailedSortMultiArrayException('Failed to sort a multi-sort array.');

        } catch (ValueError) {

            throw new ArrSizeInconsistentException('Array sizes are inconsistent.');

        }

    }

    /**
     * ### Apply a user function to every member of an array
     *
     * Applies the user-defined callback function to each element of the array $array. Method is not affected by the
     * internal array pointer of an array. Method will walk through the entire array regardless of pointer position.
     * @since 1.0.0
     *
     * @template TKey of array-key
     * @template TValue
     *
     * @param array<TKey, TValue> &$array <p>
     * The array to apply a user function.
     * </p>
     * @param callable(TValue, TKey):mixed $callback <p>
     * Typically, the function name takes on two parameters. The array parameter's value is the first, and the key/index
     * second. If a function name needs to be working with the actual values of the array, specify the first
     * parameter of the function name as a reference. Then, any changes made to those elements will be made in the
     * original array itself. Users may not change the array itself from the callback function, for example, add/delete
     * elements, unset elements, and so on.
     * </p>
     * @phpstan-param-out array<TKey, TValue> $array
     *
     * @throws ArgumentCountError If the $callback function requires more than two parameters.
     *
     * @return true True on success.
     */
    public static function walk (array &$array, callable $callback):true {

        return array_walk($array, $callback);

    }

}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel;

use FireHub\Core\Support\LowLevel\Exceptions\Arr\ {
    ArrSizeInconsistentException, FailedSortMultiArrayException
};
use ArgumentCountError, ValueError;

use function array_is_list;
use function array_key_exists;
use function array_multisort;
use function in_array;

/**
 * ### Array low-level proxy class
 * @since 1.0.0
 *
 * @internal
 */
final class Arr {

    /**
     * ### Checks if the given key or index exists in the array
     *
     * Returns true if the given key is set in the array. Key can be any value possible for an array index.
     * @since 1.0.0
     *
     * @param array-key $key <p>
     * Key to check.
     * </p>
     * @param array<array-key, mixed> $array <p>
     * An array with keys to check.
     * </p>
     *
     * @return bool True if the key exists in an array, false otherwise.
     *
     * @note Method will search for the keys in the first dimension only. Nested keys in multidimensional arrays will
     * not be found.
     */
    public static function keyExist (int|string $key, array $array):bool {

        return array_key_exists($key, $array);

    }

    /**
     * ### Checks if a value exists in an array
     * @since 1.0.0
     *
     * @param mixed $value <p>
     * The searched value.
     * note: If a needle is a string, the comparison is done in a case-sensitive manner.
     * </p>
     * @param array<array-key, mixed> $array <p>
     * The array.
     * </p>
     *
     * @return bool True if a value is found in the array, false otherwise.
     */
    public static function inArray (mixed $value, array $array):bool {

        return in_array($value, $array, true);

    }

    /**
     * ### Checks whether a given array is a list
     *
     * Determines if the given array is a list. An array is considered a list if its keys consist of consecutive
     * numbers from 0 to count($array)-1.
     * @since 1.0.0
     *
     * @param array<array-key, mixed> $array <p>
     * The array is being evaluated.
     * </p>
     *
     * @return ($array is list ? true: false) True if an array is a list, false otherwise.
     *
     * @note This function returns true on empty arrays.
     */
    public static function isList (array $array):bool {

        return array_is_list($array);

    }

    /**
     * ### Sort multiple on multidimensional arrays
     * @since 1.0.0
     *
     * @param array<array-key, array<array-key, mixed>> $array <p>
     * A multidimensional array being sorted.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Arr\FailedSortMultiArrayException Failed to sort a multi-sort array.
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Arr\ArrSizeInconsistentException If array sizes are inconsistent.
     *
     * @return bool True on success.
     *
     * @caution Associative (string) keys will be maintained, but numeric keys will be re-indexed.
     * @note Resets array's internal pointer to the first element.
     *
     * @phpstan-ignore return.phpDocType (PHPStan reports that the method could still return bool)
     */
    public static function multiSort (array $array):true {

        try {

            return array_multisort(...$array)
                ?: throw new FailedSortMultiArrayException('Failed to sort a multi-sort array.');

        } catch (ValueError) {

            throw new ArrSizeInconsistentException('Array sizes are inconsistent.');

        }

    }

    /**
     * ### Apply a user function to every member of an array
     *
     * Applies the user-defined callback function to each element of the array $array. Method is not affected by the
     * internal array pointer of an array. Method will walk through the entire array regardless of pointer position.
     * @since 1.0.0
     *
     * @template TKey of array-key
     * @template TValue
     *
     * @param array<TKey, TValue> &$array <p>
     * The array to apply a user function.
     * </p>
     * @param callable(TValue $value, TKey $key):mixed $callback <p>
     * <code>callable (TValue $value, TKey $key):mixed</code>
     * Typically, the function name takes on two parameters. The array parameter's value is the first, and the key/index
     * second. If a function name needs to be working with the actual values of the array, specify the first
     * parameter of the function name as a reference. Then, any changes made to those elements will be made in the
     * original array itself. Users may not change the array itself from the callback function, for example, add/delete
     * elements, unset elements, and so on.
     * </p>
     * @phpstan-param-out array<TKey, TValue> $array
     *
     * @throws ArgumentCountError If the $callback function requires more than two parameters.
     *
     * @return true True on success.
     */
    public static function walk (array &$array, callable $callback):true {

        return array_walk($array, $callback);

    }

}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel;

use FireHub\Core\Support\LowLevel\Exceptions\Autoload\ {
    AutoloadRegisterException, ClassNotFoundException
};
use LogicException;

use function spl_autoload;
use function spl_autoload_extensions;
use function spl_autoload_register;
use function spl_autoload_unregister;

/**
 * ### SPL Autoload low-level proxy class
 * @since 1.0.0
 *
 * @internal
 */
final class SplAutoload {

    /**
     * ### Default autoload implementation
     *
     * This function is intended to be used as a default implementation for [[SplAutoload#register()]].
     * If nothing else is specified and the register method is called without any parameters,
     * then this function will be used for any later call to autoload.
     * @since 1.0.0
     *
     * @param class-string $class <p>
     * The name of the class (and namespace) being instantiated.
     * </p>
     * @param null|string $file_extensions [optional] <p>
     * By default, it checks all include paths to contain filenames built up by the lowercase class name appended by the
     * filename extensions .inc and .php.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Autoload\ClassNotFoundException When the class is not found
     * and there are no other autoloaders registered.
     *
     * @return void
     */
    public static function default (string $class, ?string $file_extensions = null):void {

        try {

            spl_autoload($class, $file_extensions);

        } catch (LogicException) {

            throw new ClassNotFoundException('Failed to register a callback function as an autoloader.');

        }

    }

    /**
     * ### Register and return file extensions for default autoload
     *
     * This function can modify and check the file extensions that the built-in autoload fallback function
     * [[SplAutoload#default()]] will be using.
     * @since 1.0.0
     *
     * @param null|non-empty-string $file_extensions [optional] <p>
     * If null, it simply returns the current list of extensions, each separated by comma.
     * To modify the list of file extensions, invoke the functions with the new list of file extensions to use
     * in a single string with each extension separated by comma.
     * </p>
     *
     * @return string A comma-delimited the list of default file extensions for default method.
     *
     * @note There shouldn't be a space between the defined file extensions.
     */
    public static function extensions (?string $file_extensions = null):string {

        return spl_autoload_extensions($file_extensions);

    }

    /**
     * ### Register a callback function as an autoloader
     *
     * Register a function with the spl provided autoloaded queue.
     * If the queue is not yet activated, it will be activated.
     * If there must be multiple autoload functions, this method allows for this.
     * It effectively creates a queue of autoload functions and runs through each of them in the order they are defined.
     * @since 1.0.0
     *
     * @param null|callable(string):void $callback [optional] <p>
     * The autoload function being registered. If no callback is provided, then the default autoloader
     * will be used.
     * </p>
     * @param bool $prepend [optional] <p>
     * Whether to prepend the autoloader on the stack instead of appending it.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Autoload\AutoloadRegisterException If failed to register a callback
     * function as an autoloader.
     *
     * @return true True if autoloader was registered.
     */
    public static function register (?callable $callback = null, bool $prepend = false):true {

        return spl_autoload_register($callback, true, $prepend)
            ?: throw new AutoloadRegisterException('Failed to register a callback function as an autoloader.');

    }

    /**
     * ### Unregister autoload implementation
     *
     * Removes a function from the autoloaded queue. If the queue is activated and empty after removing the given
     * function, then it will be deactivated. When this function results in the queue being deactivated, any autoload
     * function that previously existed will not be reactivated.
     * @since 1.0.0
     *
     * @param callable(string):void $callback <p>
     * The autoload function that will be unregistered.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Autoload\AutoloadRegisterException If failed to unregister
     * autoloader implementation.
     *
     * @return true True if autoloader was unregistered.
     */
    public static function unregister (callable $callback):true {

        return spl_autoload_unregister($callback)
            ?: throw new AutoloadRegisterException('Failed to unregister autoload implementation.');

    }

    /**
     * ### Get all registered autoload functions
     * @since 1.0.0
     *
     * @return array<array-key, mixed> An array of all registered autoload functions.
     * If no function is registered, or autoloaded queue is not activated, then the return value will be an empty array.
     */
    public static function functions ():array {

        return spl_autoload_functions();

    }

    /**
     * ### Try all registered autoload functions to load the requested class
     * @since 1.0.0
     *
     * @param class-string $class <p>
     * Fully qualified class name that is being called.
     * </p>
     *
     * @return void
     *
     * @note This method can be used to manually search for a class or interface using the registered autoloader
     * functions.
     */
    public static function load (string $class):void {

        spl_autoload_call($class);

    }

}<?php declare(strict_types = 1);

/**
 * This file is part of the FireHub Web Application Framework package
 *
 * @author Danijel Galiƒá <danijel.galic@outlook.com>
 * @copyright 2025 FireHub Web Application Framework
 * @license <https://opensource.org/licenses/OSL-3.0> OSL Open Source License version 3
 *
 * @package Core\Support
 *
 * @version GIT: $Id$ Blob checksum.
 */

namespace FireHub\Core\Support\LowLevel;

use FireHub\Core\Support\LowLevel\Exceptions\Autoload\ {
    AutoloadRegisterException, ClassNotFoundException
};
use LogicException;

use function spl_autoload;
use function spl_autoload_extensions;
use function spl_autoload_register;
use function spl_autoload_unregister;

/**
 * ### SPL Autoload low-level proxy class
 * @since 1.0.0
 *
 * @internal
 */
final class SplAutoload {

    /**
     * ### Default autoload implementation
     *
     * This function is intended to be used as a default implementation for [[SplAutoload#register()]].
     * If nothing else is specified and the register method is called without any parameters,
     * then this function will be used for any later call to autoload.
     * @since 1.0.0
     *
     * @param class-string $class <p>
     * The name of the class (and namespace) being instantiated.
     * </p>
     * @param null|string $file_extensions [optional] <p>
     * By default, it checks all include paths to contain filenames built up by the lowercase class name appended by the
     * filename extensions .inc and .php.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Autoload\ClassNotFoundException When the class is not found
     * and there are no other autoloaders registered.
     *
     * @return void
     */
    public static function default (string $class, ?string $file_extensions = null):void {

        try {

            spl_autoload($class, $file_extensions);

        } catch (LogicException) {

            throw new ClassNotFoundException('Failed to register a callback function as an autoloader.');

        }

    }

    /**
     * ### Register and return file extensions for default autoload
     *
     * This function can modify and check the file extensions that the built-in autoload fallback function
     * [[SplAutoload#default()]] will be using.
     * @since 1.0.0
     *
     * @param null|non-empty-string $file_extensions [optional] <p>
     * If null, it simply returns the current list of extensions, each separated by comma.
     * To modify the list of file extensions, invoke the functions with the new list of file extensions to use
     * in a single string with each extension separated by comma.
     * </p>
     *
     * @return string A comma-delimited the list of default file extensions for default method.
     *
     * @note There shouldn't be a space between the defined file extensions.
     */
    public static function extensions (?string $file_extensions = null):string {

        return spl_autoload_extensions($file_extensions);

    }

    /**
     * ### Register a callback function as an autoloader
     *
     * Register a function with the spl provided autoloaded queue.
     * If the queue is not yet activated, it will be activated.
     * If there must be multiple autoload functions, this method allows for this.
     * It effectively creates a queue of autoload functions and runs through each of them in the order they are defined.
     * @since 1.0.0
     *
     * @param null|callable(string):void $callback [optional] <p>
     * The autoload function being registered. If no callback is provided, then the default autoloader
     * will be used.
     * </p>
     * @param bool $prepend [optional] <p>
     * Whether to prepend the autoloader on the stack instead of appending it.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\Autoload\AutoloadRegisterException If failed to register a callback
     * function as an autoloader.
     *
     * @return true True if autoloader was registered.
     */
    public static function register (?callable $callback = null, bool $prepend = false):true {

        return spl_autoload_register($callback, true, $prepend)
            ?: throw new AutoloadRegisterException('Failed to register a callback function as an autoloader.');

    }

    /**
     * ### Unregister autoload implementation
     *
     * Removes a function from the autoloaded queue. If the queue is activated and empty after removing the given
     * function, then it will be deactivated. When this function results in the queue being deactivated, any autoload
     * function that previously existed will not be reactivated.
     * @since 1.0.0
     *
     * @param callable(string):void $callback <p>
     * The autoload function that will be unregistered.
     * </p>
     *
     * @throws \FireHub\Core\Support\LowLevel\Exceptions\AutoloadRegisterException If failed to unregister autoloader
     * implementation.
     *
     * @return true True if autoloader was unregistered.
     */
    public static function unregister (callable $callback):true {

        return spl_autoload_unregister($callback)
            ?: throw new AutoloadRegisterException('Failed to unregister autoload implementation.');

    }

    /**
     * ### Get all registered autoload functions
     * @since 1.0.0
     *
     * @return array<array-key, mixed> An array of all registered autoload functions.
     * If no function is registered, or autoloaded queue is not activated, then the return value will be an empty array.
     */
    public static function functions ():array {

        return spl_autoload_functions();

    }

    /**
     * ### Try all registered autoload functions to load the requested class
     * @since 1.0.0
     *
     * @param class-string $class <p>
     * Fully qualified class name that is being called.
     * </p>
     *
     * @return void
     *
     * @note This method can be used to manually search for a class or interface using the registered autoloader
     * functions.
     */
    public static function load (string $class):void {

        spl_autoload_call($class);

    }

}<?php declare(strict_types = 1);

use PHPMD\AbstractNode;
use PHPMD\Rule\CleanCode\BooleanArgumentFlag as ParentBooleanArgumentFlag;

/**
 * ### Check for a boolean flag in the method/ function signature
 *
 * Boolean flags are signs for single responsibility principle violations.
 * @since 1.0.0
 */
final class src_testing_phpmd_BooleanArgumentFlag extends ParentBooleanArgumentFlag {

    /**
     * ### Applies the rule to the given node.
     *
     * If the node's namespace matches the 'exclude_namespaces' property,
     * the rule is not applied. Otherwise, the parent apply method is invoked.
     * @since 1.0.0
     *
     * @param \PHPMD\AbstractNode $node <p>
     * The node to which the rule is applied.
     * </p>
     *
     * @return void
     */
    #[\Override]
    public function apply (AbstractNode $node):void {

        if (\in_array(
            $node->getNamespaceName(),
            explode(',', $this->getStringProperty('exclude_namespaces')),
            true
        )) return;

        parent::apply($node);

    }

}YL4D≥VΩ{≥¶
™¡¡∑ﬁä«{<¯ø’~√•∂$˛#ëUyûﬁn∞W[+K™i!˙4ÅZ:>⁄
S™^@m«äYµ«Gã‹“)
d¯#Ô∑(§0;jíÅFÌ∆p"7¢fÍ1_πÕâÿh°xe‘%ÏÃb<ﬂ|∏À‡ÊØî¶
HS˜Á6£aÂ·üøˆJöı≥.ÿ»:e 1÷ò¯n™"{CÊE⁄#ﬁâÎù∂
1¬Îë–E‚§ËÍò/ÓÔ2jÂÀB{tßÂò…(|l£‘¢≤8M~‘tëY“%ÆYçò|¡á8±€«Ò[ñÑoŸ¯Ò÷*ZGiq{˚V®4ßöæ¯`°J„)á&{®›˚*ëπu4>LBØË∑Ìôã_é7ÄT•ÓÜMg¬Á®®ŒdÀ
Í*°iêê€uá1∑ˆk xŸ.€—=g/=o§Í˝€Mﬂ$iÜ8ÌÊK5‰À_≠ÙïÇ>≤ˆ±uNçÍ‘cJ0û⁄3*ˇ∫¬L∑ΩqZWpV‘H)Èw’1*‘èô®]v\⁄ˆ-´∆%úq∑S‡
K
q∂√i@®f£Ic<•≠g^E©‚
q¸Vªÿã‹
¨©{U&ü6ÏÁåiåæeÎ#Ñ¨b”ÌbÚsAZxô3*Ç!ÙCò*Ïôn      GBMB