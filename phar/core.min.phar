<?php

$web = '/public/index.php';

if (\in_array('phar', stream_get_wrappers()) && class_exists(\Phar::class, 0)) {
    \Phar::interceptFileFuncs();
    set_include_path('phar://'.__FILE__.\PATH_SEPARATOR.get_include_path());
    \Phar::webPhar(null, $web);

    include 'phar://'.__FILE__.'/'.\Extract_Phar::START;

    return;
}

if ((isset($_SERVER['REQUEST_URI'], $_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {
    \Extract_Phar::go(true);
    $mimes = [
        'phps' => 2,
        'c' => 'text/plain',
        'cc' => 'text/plain',
        'cpp' => 'text/plain',
        'c++' => 'text/plain',
        'dtd' => 'text/plain',
        'h' => 'text/plain',
        'log' => 'text/plain',
        'rng' => 'text/plain',
        'txt' => 'text/plain',
        'xsd' => 'text/plain',
        'php' => 1,
        'inc' => 1,
        'avi' => 'video/avi',
        'bmp' => 'image/bmp',
        'css' => 'text/css',
        'gif' => 'image/gif',
        'htm' => 'text/html',
        'html' => 'text/html',
        'htmls' => 'text/html',
        'ico' => 'image/x-ico',
        'jpe' => 'image/jpeg',
        'jpg' => 'image/jpeg',
        'jpeg' => 'image/jpeg',
        'js' => 'application/x-javascript',
        'midi' => 'audio/midi',
        'mid' => 'audio/midi',
        'mod' => 'audio/mod',
        'mov' => 'movie/quicktime',
        'mp3' => 'audio/mp3',
        'mpg' => 'video/mpeg',
        'mpeg' => 'video/mpeg',
        'pdf' => 'application/pdf',
        'png' => 'image/png',
        'swf' => 'application/shockwave-flash',
        'tif' => 'image/tiff',
        'tiff' => 'image/tiff',
        'wav' => 'audio/wav',
        'xbm' => 'image/xbm',
        'xml' => 'text/xml',
    ];

    header('Cache-Control: no-cache, must-revalidate');
    header('Pragma: no-cache');

    $basename = basename(__FILE__);

    if (!strpos($_SERVER['REQUEST_URI'], $basename)) {
        chdir(\Extract_Phar::$temp);

        include $web;

        return;
    }
    $pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + \strlen($basename));

    if (!$pt || $pt == '/') {
        $pt = $web;
        header('HTTP/1.1 301 Moved Permanently');
        header('Location: '.$_SERVER['REQUEST_URI'].'/'.$pt);

        exit;
    }
    $a = realpath(\Extract_Phar::$temp.\DIRECTORY_SEPARATOR.$pt);

    if (!$a || \strlen(\dirname($a)) < \strlen(\Extract_Phar::$temp)) {
        header('HTTP/1.0 404 Not Found');
        echo "<html>\n <head>\n  <title>File Not Found<title>\n </head>\n <body>\n  <h1>404 - File Not Found</h1>\n </body>\n</html>";

        exit;
    }
    $b = pathinfo($a);

    if (!isset($b['extension'])) {
        header('Content-Type: text/plain');
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }

    if (isset($mimes[$b['extension']])) {
        if ($mimes[$b['extension']] === 1) {
            include $a;

            exit;
        }

        if ($mimes[$b['extension']] === 2) {
            highlight_file($a);

            exit;
        }
        header('Content-Type: '.$mimes[$b['extension']]);
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }
}

final class Extract_Phar {
    public const GZ = 0x10_00;
    public const BZ2 = 0x20_00;
    public const MASK = 0x30_00;
    public const START = '/public/console.php';
    public const LEN = 6_661;
    public static $temp;
    public static $origdir;

    public static function go($return = false): void {
        $fp = fopen(__FILE__, 'rb');
        fseek($fp, self::LEN);
        $L = unpack('V', $a = fread($fp, 4));
        $m = '';

        do {
            $read = 8_192;

            if ($L[1] - \strlen($m) < 8_192) {
                $read = $L[1] - \strlen($m);
            }
            $last = fread($fp, $read);
            $m .= $last;
        } while (\strlen($last) && \strlen($m) < $L[1]);

        if (\strlen($m) < $L[1]) {
            exit('ERROR: manifest length read was "'
            .\strlen($m).'" should be "'
            .$L[1].'"');
        }

        $info = self::_unpack($m);
        $f = $info['c'];

        if ($f & self::GZ) {
            if (!\function_exists('gzinflate')) {
                exit('Error: zlib extension is not enabled -'
                .' gzinflate() function needed for zlib-compressed .phars');
            }
        }

        if ($f & self::BZ2) {
            if (!\function_exists('bzdecompress')) {
                exit('Error: bzip2 extension is not enabled -'
                .' bzdecompress() function needed for bz2-compressed .phars');
            }
        }

        $temp = self::tmpdir();

        if (!$temp || !is_writable($temp)) {
            $sessionpath = session_save_path();

            if (str_contains($sessionpath, ';'))
                $sessionpath = substr($sessionpath, strpos($sessionpath, ';') + 1);

            if (!file_exists($sessionpath) || !is_dir($sessionpath)) {
                exit('Could not locate temporary directory to extract phar');
            }
            $temp = $sessionpath;
        }

        $temp .= '/pharextract/'.basename(__FILE__, '.phar');
        self::$temp = $temp;
        self::$origdir = getcwd();
        mkdir($temp, 0o777, true);
        $temp = realpath($temp);

        if (!file_exists($temp.\DIRECTORY_SEPARATOR.md5_file(__FILE__))) {
            self::_removeTmpFiles($temp, getcwd());
            mkdir($temp, 0o777, true);
            file_put_contents($temp.'/'.md5_file(__FILE__), '');

            foreach ($info['m'] as $path => $file) {
                $a = !file_exists(\dirname($temp.'/'.$path));
                mkdir(\dirname($temp.'/'.$path), 0o777, true);
                clearstatcache();

                if ($path[\strlen($path) - 1] == '/') {
                    mkdir($temp.'/'.$path, 0o777);
                } else {
                    file_put_contents($temp.'/'.$path, self::extractFile($path, $file, $fp));
                    chmod($temp.'/'.$path, 0o666);
                }
            }
        }

        chdir($temp);

        if (!$return) {
            include self::START;
        }
    }

    public static function tmpdir() {
        if (str_contains(\PHP_OS, 'WIN')) {
            if ($var = getenv('TMP') ?: getenv('TEMP')) {
                return $var;
            }

            if (is_dir('/temp') || mkdir('/temp')) {
                return realpath('/temp');
            }

            return false;
        }

        if ($var = getenv('TMPDIR')) {
            return $var;
        }

        return realpath('/tmp');
    }

    public static function _unpack($m) {
        $info = unpack('V', substr($m, 0, 4));
        $l = unpack('V', substr($m, 10, 4));
        $m = substr($m, 14 + $l[1]);
        $s = unpack('V', substr($m, 0, 4));
        $o = 0;
        $start = 4 + $s[1];
        $ret['c'] = 0;

        for ($i = 0; $i < $info[1]; $i++) {
            $len = unpack('V', substr($m, $start, 4));
            $start += 4;
            $savepath = substr($m, $start, $len[1]);
            $start += $len[1];
            $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));
            $ret['m'][$savepath][3] = \sprintf('%u', $ret['m'][$savepath][3]
            & 0xFF_FF_FF_FF);
            $ret['m'][$savepath][7] = $o;
            $o += $ret['m'][$savepath][2];
            $start += 24 + $ret['m'][$savepath][5];
            $ret['c'] |= $ret['m'][$savepath][4] & self::MASK;
        }

        return $ret;
    }

    public static function extractFile($path, $entry, $fp) {
        $data = '';
        $c = $entry[2];

        while ($c) {
            if ($c < 8_192) {
                $data .= fread($fp, $c);
                $c = 0;
            } else {
                $c -= 8_192;
                $data .= fread($fp, 8_192);
            }
        }

        if ($entry[4] & self::GZ) {
            $data = gzinflate($data);
        } elseif ($entry[4] & self::BZ2) {
            $data = bzdecompress($data);
        }

        if (\strlen($data) != $entry[0]) {
            exit('Invalid internal .phar file (size error '.\strlen($data).' != '
            .$stat[7].')');
        }

        if ($entry[3] != \sprintf('%u', crc32($data) & 0xFF_FF_FF_FF)) {
            exit('Invalid internal .phar file (checksum error)');
        }

        return $data;
    }

    public static function _removeTmpFiles($temp, $origdir): void {
        chdir($temp);

        foreach (glob('*') as $f) {
            if (file_exists($f)) {
                is_dir($f) ? rmdir($f) : unlink($f);

                if (file_exists($f) && is_dir($f)) {
                    self::_removeTmpFiles($f, getcwd());
                }
            }
        }

        rmdir($temp);
        clearstatcache();
        chdir($origdir);
    }
}

\Extract_Phar::go();
__HALT_COMPILER(); ?>
¢  5           7   a:2:{s:4:"name";s:4:"core";s:7:"version";s:6:"v0.1.3";}&   components/error/firehub.Exception.phpÉ  k@gÉ  ‰kC∂         public/console.php!   k@g!   ∑,MŒ∂         public/index.php!   k@g!   ∑,MŒ∂      $   support/constants/firehub.Number.php{  k@g{  :“c∂      '   support/enums/data/firehub.Category.phpá   k@gá   ∆·ŒÒ∂      +   support/enums/data/firehub.ResourceType.phpù	  k@gù	  +A',∂      #   support/enums/data/firehub.Type.php≠  k@g≠  }q≥∂         support/enums/firehub.Order.phpÔ   k@gÔ   T“^ ∂         support/enums/firehub.Sort.php  k@g  ”ı‰X∂      ,   support/enums/string/firehub.CaseFolding.phpñ   k@gñ   -S>Ù∂      )   support/enums/string/firehub.Encoding.phpç	  k@gç	  ˚+¬R∂      ?   support/exceptions/arr/firehub.ChunkLengthTooSmallException.phpX  k@gX  N≈±}∂      @   support/exceptions/arr/firehub.FailedSortMultiArrayException.php/  k@g/  °?ø—∂      J   support/exceptions/arr/firehub.KeysAndValuesSameNumberOfElemsException.phpM  k@gM  "ÂD]∂      6   support/exceptions/arr/firehub.OutOfRangeException.php  k@g  îYyi∂      <   support/exceptions/arr/firehub.SizeInconsistentException.php&  k@g&  ¬∏
r∂      =   support/exceptions/arr/firehub.WalkArgumentCountException.php?  k@g?  „Wa∂      >   support/exceptions/autoload/firehub.ClassNotFoundException.php|  k@g|  1ˆÙß∂      C   support/exceptions/autoload/firehub.RegisterAutoloaderException.phpR  k@gR  ˆ∞ô∂      E   support/exceptions/autoload/firehub.UnregisterAutoloaderException.phpV  k@gV  7ÃÉé∂      A   support/exceptions/char/firehub.CharacterToCodepointException.phpy  k@gy  É…ˆ∂      ?   support/exceptions/cls/firehub.FailedToCreateAliasException.phpÑ  k@gÑ  Ô3‚–∂      4   support/exceptions/cls/firehub.NotFoundException.php@  k@g@  nñ@∂      F   support/exceptions/codepoint/firehub.CodepointToCharacterException.phpÑ  k@gÑ  ®¥®d∂      ?   support/exceptions/constant/firehub.FailedToDefineException.phph  k@gh  {…ƒ∂      D   support/exceptions/data/firehub.ArrayToStringConversionException.php2  k@g2  œÑ„ﬁ∂      <   support/exceptions/data/firehub.CannotSerializeException.php!  k@g!  ›
~∂      <   support/exceptions/data/firehub.FailedToSetTypeException.php
  k@g
   P˙Ï∂      :   support/exceptions/data/firehub.SetAsResourceException.php(  k@g(  õrs∂      8   support/exceptions/data/firehub.TypeUnknownException.php  k@g  ˛z*¨∂      >   support/exceptions/data/firehub.UnserializeFailedException.php%  k@g%  0É"∂      +   support/exceptions/firehub.ArrException.php†   k@g†   õÙN§∂      0   support/exceptions/firehub.AutoloadException.php•   k@g•   sÄ∂      ,   support/exceptions/firehub.CharException.php  k@g  5c%∂      +   support/exceptions/firehub.ClsException.php%  k@g%  ∞9Àì∂      1   support/exceptions/firehub.CodepointException.php4  k@g4  Ü“oö∂      0   support/exceptions/firehub.ConstantException.php3  k@g3  )TÆõ∂      ,   support/exceptions/firehub.DataException.php°   k@g°   õbÎ]∂          support/lowlevel/firehub.Arr.php€.  k@g€.  ˝‹˘E∂      #   support/lowlevel/firehub.CharMB.phpv  k@gv  <ÒP|∂      #   support/lowlevel/firehub.CharSB.php"  k@g"  ùV£∂          support/lowlevel/firehub.Cls.php+  k@g+  vViS∂      #   support/lowlevel/firehub.ClsObj.phpè
  k@gè
  ãy˚∂      %   support/lowlevel/firehub.Constant.php:  k@g:  ¯$®{∂      !   support/lowlevel/firehub.Data.phpA	  k@gA	  
:∑Â∂      #   support/lowlevel/firehub.DataIs.php§  k@g§  ,E‘∂          support/lowlevel/firehub.Obj.php¥  k@g¥  pôÛe∂      (   support/lowlevel/firehub.SplAutoload.php)  k@g)  VŒ„∂         testing/firehub.Base.phpà   k@gà   9*À∂      %   testing/phpmd/BooleanArgumentFlag.phpÿ  k@gÿ  ß+T›∂         testing/phpmd/LongClass.php≠  k@g≠  QAß…∂          testing/phpmd/TooManyMethods.php¡  k@g¡  dô∂      &   testing/phpmd/TooManyPublicMethods.phpŸ  k@gŸ  œ∂      <?php declare(strict_types = 1); namespace FireHub\Core\Components\Error; use Exception as InternalException; class Exception extends InternalException { public function __construct () { parent::__construct(); } public function withMessage (string $message):static { $this->message = $message; return $this; } public function appendMessage (string $message):static { $this->message .= ' '.$message; return $this; } public function appendMessageIfExists (mixed $check, string $message):static { return isset($check) ? $this->appendMessage($message) : $this; } public function withCode (int $code):static { $this->code = $code; return $this; } }<?php declare(strict_types = 1); <?php declare(strict_types = 1); <?php declare(strict_types = 1); namespace FireHub\Core\Support\Constants\Number; use const INF as PHP_INF; use const NAN as PHP_NAN; use const PHP_FLOAT_DIG; use const PHP_FLOAT_EPSILON; use const PHP_FLOAT_MAX; use const PHP_FLOAT_MIN; use const PHP_INT_MAX; use const PHP_INT_MIN; use const PHP_INT_SIZE; const MIN = PHP_INT_MIN; const MAX = PHP_INT_MAX; const MIN_32_BIT = -2_147_483_648; const MAX_32_BIT = 2_147_483_648; const SIZE = PHP_INT_SIZE; const FLOAT_DIG = PHP_FLOAT_DIG; const FLOAT_EPSILON = PHP_FLOAT_EPSILON; const FLOAT_MIN = PHP_FLOAT_MIN; const FLOAT_MAX = PHP_FLOAT_MAX; const INF = PHP_INF; const NAN = PHP_NAN;<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums\Data; enum Category { case SCALAR; case COMPOUND; case SPECIAL; }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums\Data; enum ResourceType:string { case UNKNOWN = 'Unknown'; case ADDRESS_INFO = 'AddressInfo'; case BZIP2 = 'bzip2'; case CUBRID_CONNECTION = 'cubrid connection'; case PERSISTENT_CUBRID_CONNECTION = 'persistent cubrid connection'; case CUBRID_REQUEST = 'cubrid request'; case CUBRID_LOB = 'cubrid lob'; case CUBRID_LOB2 = 'cubrid lob2'; case CURL = 'curl'; case CURL_MULTI = 'curl_multi'; case CURL_SHARE = 'curl_share'; case DBA = 'dba'; case DBA_PERSISTENT = 'dba persistent'; case DBASE = 'dbase'; case ENCHANT_BROKER = 'enchant_broker'; case ENCHANT_DICT = 'enchant_dict'; case FDF = 'fdf'; case FTP = 'ftp'; case GD = 'gd'; case GD_FONT = 'gd font'; case IMAP = 'imap'; case INTERBASE_BLOB = 'interbase blob'; case INTERBASE_LINK = 'interbase link'; case INTERBASE_LINK_PERSISTENT = 'interbase link persistent'; case INTERBASE_QUERY = 'interbase query'; case INTERBASE_RESULT = 'interbase result'; case INTERBASE_TRANSACTION = 'interbase transaction'; case LDAP_LINK = 'ldap link'; case LDAP_RESULT = 'ldap result'; case LDAP_RESULT_ENTRY = 'ldap result entry'; case MAILPARSE_MAIL_STRUCTURE = 'mailparse_mail_structure'; case MYSQL_LINK = 'mysql link'; case MYSQL_LINK_PERSISTENT = 'mysql link persistent'; case MYSQL_RESULT = 'mysql result'; case OCI8_COLLECTION = 'oci8 collection'; case OCI8_CONNECTION = 'oci8 connection'; case OCI8_LOB = 'oci8 lob'; case OCI8_STATEMENT = 'oci8 statement'; case ODBC_LINK = 'odbc link'; case ODBC_LINK_PERSISTENT = 'odbc link persistent'; case ODBC_RESULT = 'odbc result'; case BIRDSTEP_LINK = 'birdstep link'; case BIRDSTEP_RESULT = 'birdstep result'; case OPENSSL_KEY = 'OpenSSL key'; case OPENSSL_X_509 = 'OpenSSL X.509'; case PGSQL_LARGE_OBJECT = 'pgsql large object'; case PGSQL_LINK = 'pgsql link'; case PGSQL_LINK_PERSISTENT = 'pgsql link persistent'; case PGSQL_RESULT = 'pgsql result'; case PGSQL_STRING = 'pgsql string'; case PSPELL = 'pspell'; case PSPELL_CONFIG = 'pspell config'; case SHMOP = 'shmop'; case SOCKET = 'Socket'; case STREAM = 'stream'; case SSH2_SESSION = 'SSH2 Session'; case SSH2_LISTENER = 'SSH2 Listener'; case SSH2_SFTP = 'SSH2 SFTP'; case SSH2_PUBLICKEY_SUBSYSTEM = 'SSH2 Publickey Subsystem'; case SYSVMSG_QUEUE = 'sysvmsg queue'; case SYSVSEM = 'sysvsem'; case SYSVSHM = 'sysvshm'; case WDDX = 'wddx'; case XML = 'xml'; case ZLIB = 'zlib'; case ZLIB_DEFLATE = 'zlib.deflate'; case ZLIB_INFLATE = 'zlib.inflate'; }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums\Data; enum Type { case T_BOOL; case T_INT; case T_FLOAT; case T_STRING; case T_ARRAY; case T_OBJECT; case T_NULL; case T_RESOURCE; public function category ():Category { return match ($this) { self::T_BOOL, self::T_INT, self::T_FLOAT, self::T_STRING => Category::SCALAR, self::T_ARRAY, self::T_OBJECT => Category::COMPOUND, default => Category::SPECIAL }; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums; enum Order:string { case ASC = 'ASC'; case DESC = 'DESC'; public function reverse ():Order { return match ($this) { self::ASC => self::DESC, default => self::ASC }; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums; enum Sort:int { case BY_REGULAR = 0; case BY_NUMERIC = 1; case BY_STRING = 2; case BY_LOCALE_STRING = 5; case BY_NATURAL = 6; case BY_STRING_FLAG_CASE = 10; case BY_NATURAL_FLAG_CASE = 14; }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums\String; enum CaseFolding:int { case LOWER = 0; case UPPER = 1; case TITLE = 2; }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Enums\String; enum Encoding:string { case BASE64 = 'BASE64'; case UUENCODE = 'UUENCODE'; case HTML_ENTITIES = 'HTML-ENTITIES'; case QUOTED_PRINTABLE = 'Quoted-Printable'; case SEVEN_BIT = '7bit'; case EIGHT_BIT = '8bit'; case UCS_4 = 'UCS-4'; case UCS_4BE = 'UCS-4BE'; case UCS_4LE = 'UCS-4LE'; case UCS_2 = 'UCS-2'; case UCS_2BE = 'UCS-2BE'; case UCS_2LE = 'UCS-2LE'; case UTF_32 = 'UTF-32'; case UTF_32BE = 'UTF-32BE'; case UTF_32LE = 'UTF-32LE'; case UTF_16 = 'UTF-16'; case UTF_16BE = 'UTF-16BE'; case UTF_16LE = 'UTF-16LE'; case UTF_8 = 'UTF-8'; case UTF_7 = 'UTF-7'; case UTF7_IMAP = 'UTF7-IMAP'; case ASCII = 'ASCII'; case EUC_JP = 'EUC-JP'; case SJIS = 'SJIS'; case EUCJP_WIN = 'eucJP-win'; case EUC_JP_2004 = 'EUC-JP-2004'; case SJIS_MOBILE_DOCOMO = 'SJIS-Mobile#DOCOMO'; case SJIS_MOBILE_KDDI = 'SJIS-Mobile#KDDI'; case SJIS_MOBILE_SOFTBANK = 'SJIS-Mobile#SOFTBANK'; case SJIS_MAC = 'SJIS-mac'; case SJIS_2004 = 'SJIS-2004'; case UTF_8_MOBILE_DOCOMO = 'UTF-8-Mobile#DOCOMO'; case UTF_8_MOBILE_KDDI_A = 'UTF-8-Mobile#KDDI-A'; case UTF_8_MOBILE_KDDI_B = 'UTF-8-Mobile#KDDI-B'; case UTF_8_MOBILE_SOFTBANK = 'UTF-8-Mobile#SOFTBANK'; case CP932 = 'CP932'; case CP51932 = 'CP51932'; case JIS = 'JIS'; case ISO_2022_JP = 'ISO-2022-JP'; case ISO_2022_JP_MS = 'ISO-2022-JP-MS'; case GB18030 = 'GB18030'; case WINDOWS_1252 = 'Windows-1252'; case WINDOWS_1254 = 'Windows-1254'; case ISO_8859_1 = 'ISO-8859-1'; case ISO_8859_2 = 'ISO-8859-2'; case ISO_8859_3 = 'ISO-8859-3'; case ISO_8859_4 = 'ISO-8859-4'; case ISO_8859_5 = 'ISO-8859-5'; case ISO_8859_6 = 'ISO-8859-6'; case ISO_8859_7 = 'ISO-8859-7'; case ISO_8859_8 = 'ISO-8859-8'; case ISO_8859_9 = 'ISO-8859-9'; case ISO_8859_10 = 'ISO-8859-10'; case ISO_8859_13 = 'ISO-8859-13'; case ISO_8859_14 = 'ISO-8859-14'; case ISO_8859_15 = 'ISO-8859-15'; case ISO_8859_16 = 'ISO-8859-16'; case EUC_CN = 'EUC-CN'; case CP936 = 'CP936'; case HZ = 'HZ'; case EUC_TW = 'EUC-TW'; case BIG_5 = 'BIG-5'; case CP950 = 'CP950'; case EUC_KR = 'EUC-KR'; case UHC = 'UHC'; case ISO_2022_KR = 'ISO-2022-KR'; case WINDOWS_1251 = 'Windows-1251'; case CP866 = 'CP866'; case KOI8_R = 'KOI8-R'; case KOI8_U = 'KOI8-U'; case ARM_SCII_8 = 'ArmSCII-8'; case CP850 = 'CP850'; case ISO_2022_JP_2004 = 'ISO-2022-JP-2004'; case ISO_2022_JP_MOBILE_KDDI = 'ISO-2022-JP-MOBILE#KDDI'; case CP50220 = 'CP50220'; case CP50221 = 'CP50221'; case CP50222 = 'CP50222'; }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class ChunkLengthTooSmallException extends ArrException { public function __construct ( protected int $length ) { $this->message = "Length is less than 1, you provided: {$this->length}."; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class FailedSortMultiArrayException extends ArrException { public function __construct () { $this->message = 'Failed to sort a multi-sort array.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class KeysAndValuesSameNumberOfElemsException extends ArrException { public function __construct () { $this->message = 'Keys and values must have the same number of elements.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class OutOfRangeException extends ArrException { public function __construct () { $this->message = 'Array is out of range.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class SizeInconsistentException extends ArrException { public function __construct () { $this->message = 'Array sizes are inconsistent.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Arr; use FireHub\Core\Support\Exceptions\ArrException; class WalkArgumentCountException extends ArrException { public function __construct () { $this->message = '$callback function requires more than two parameters.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Autoload; use FireHub\Core\Support\Exceptions\AutoloadException; class ClassNotFoundException extends AutoloadException { public function __construct ( protected string $class ) { $this->message = "Class: {$this->class} not found and there are no other autoloaders registered."; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Autoload; use FireHub\Core\Support\Exceptions\AutoloadException; class RegisterAutoloaderException extends AutoloadException { public function __construct () { $this->message = 'Failed to register a callback function as an autoloader.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Autoload; use FireHub\Core\Support\Exceptions\AutoloadException; class UnregisterAutoloaderException extends AutoloadException { public function __construct () { $this->message = 'Failed to unregister a callback function as an autoloader.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Char; use FireHub\Core\Support\Exceptions\CharException; class CharacterToCodepointException extends CharException { public function __construct ( protected string $character ) { parent::__construct($character); $this->message = "Character: {$this->character} could not be converted to codepoint."; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Cls; use FireHub\Core\Support\Exceptions\ClsException; class FailedToCreateAliasException extends ClsException { public function __construct ( protected string $class, protected string $alias ) { parent::__construct($class); $this->message = "Failed to create alias: {$this->alias} for class {$this->class}."; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Cls; use FireHub\Core\Support\Exceptions\ClsException; class NotFoundException extends ClsException { public function __construct ( protected string $class ) { parent::__construct($class); $this->message = "Class: {$this->class} not found."; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Codepoint; use FireHub\Core\Support\Exceptions\CodepointException; class CodepointToCharacterException extends CodepointException { public function __construct ( protected int $codepoint ) { parent::__construct($codepoint); $this->message = "Codepoint: {$this->codepoint} couldn't be converted to character."; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Constant; use FireHub\Core\Support\Exceptions\ConstantException; class FailedToDefineException extends ConstantException { public function __construct ( protected string $constant ) { $this->message = "Failed to define constant: {$this->constant}."; parent::__construct($constant); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Exceptions\DataException; class ArrayToStringConversionException extends DataException { public function __construct () { $this->message = 'Cannot convert array to string.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Exceptions\DataException; class CannotSerializeException extends DataException { public function __construct () { $this->message = 'Cannot serialize data.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Enums\Data\Type; use FireHub\Core\Support\Exceptions\DataException; class FailedToSetTypeException extends DataException { public function __construct ( protected Type $type ) { $this->message = 'Failed to set a type to: '.$this->type::class.' for value.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Exceptions\DataException; class SetAsResourceException extends DataException { public function __construct () { $this->message = 'Type cannot be set to resource.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Exceptions\DataException; class TypeUnknownException extends DataException { public function __construct () { $this->message = 'Data type is unknown.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions\Data; use FireHub\Core\Support\Exceptions\DataException; class UnserializeFailedException extends DataException { public function __construct () { $this->message = 'Cannot unserialize data.'; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class ArrException extends Exception {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class AutoloadException extends Exception {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Support\Enums\String\Encoding; use FireHub\Core\Components\Error\Exception; class CharException extends Exception { public function __construct ( protected string $character ) { $this->message = "Character: {$this->character} error."; parent::__construct(); } public function withEncoding (?Encoding $encoding = null):static { return $this->appendMessageIfExists($encoding, 'Character encoding: '.($encoding ? $encoding::class : '').'.'); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class ClsException extends Exception { public function __construct ( protected string $class ) { $this->message = "Class: {$this->class} error."; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class CodepointException extends Exception { public function __construct ( protected int $codepoint ) { $this->message = "Codepoint: {$this->codepoint} error."; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class ConstantException extends Exception { public function __construct ( protected string $constant ) { $this->message = "Constant: {$this->constant} error."; parent::__construct(); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\Exceptions; use FireHub\Core\Components\Error\Exception; class DataException extends Exception {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Enums\ { Order, Sort, String\CaseFolding }; use FireHub\Core\Support\Exceptions\Arr\ { ChunkLengthTooSmallException, FailedSortMultiArrayException, KeysAndValuesSameNumberOfElemsException, OutOfRangeException, SizeInconsistentException, WalkArgumentCountException }; use ArgumentCountError, ValueError; use const FireHub\Core\Support\Constants\Number\MAX_32_BIT; use const ARRAY_FILTER_USE_BOTH; use const ARRAY_FILTER_USE_KEY; use const CASE_LOWER; use const CASE_UPPER; use const SORT_REGULAR; use function array_all; use function array_any; use function array_change_key_case; use function array_chunk; use function array_column; use function array_combine; use function array_count_values; use function array_diff; use function array_diff_assoc; use function array_diff_key; use function array_diff_uassoc; use function array_diff_ukey; use function array_fill; use function array_fill_keys; use function array_filter; use function array_find; use function array_find_key; use function array_flip; use function array_intersect; use function array_intersect_assoc; use function array_intersect_key; use function array_intersect_uassoc; use function array_intersect_ukey; use function array_is_list; use function array_key_exists; use function array_key_first; use function array_key_last; use function array_keys; use function array_map; use function array_merge; use function array_merge_recursive; use function array_multisort; use function array_pad; use function array_pop; use function array_product; use function array_push; use function array_rand; use function array_reduce; use function array_replace; use function array_replace_recursive; use function array_reverse; use function array_search; use function array_shift; use function array_slice; use function array_splice; use function array_sum; use function array_udiff; use function array_udiff_assoc; use function array_udiff_uassoc; use function array_uintersect; use function array_uintersect_assoc; use function array_uintersect_uassoc; use function array_unique; use function array_unshift; use function array_values; use function array_walk; use function array_walk_recursive; use function arsort; use function asort; use function rsort; use function in_array; use function krsort; use function ksort; use function range; use function shuffle; use function sort; use function uasort; use function uksort; use function usort; final class Arr { public static function all (array $array, callable $callback):bool { return array_all($array, $callback); } public static function any (array $array, callable $callback):bool { return array_any($array, $callback); } public static function keyExist (int|string $key, array $array):bool { return array_key_exists($key, $array); } public static function inArray (mixed $value, array $array):bool { return in_array($value, $array, true); } public static function isList (array $array):bool { return array_is_list($array); } public static function multiSort (array $array):true { try { return array_multisort(...$array) ?: throw new FailedSortMultiArrayException; } catch (ValueError) { throw new SizeInconsistentException; } } public static function walk (array &$array, callable $callback):true { try { return array_walk($array, $callback); } catch (ArgumentCountError) { throw new WalkArgumentCountException; } } public static function walkRecursive (array &$array, callable $callback):true { try { return array_walk_recursive($array, $callback); } catch (ArgumentCountError) { throw new WalkArgumentCountException; } } public static function countValues (array $array):array { return array_count_values($array); } public static function fill (mixed $value, int $start_index, int $length):array { return !($length < 0) && !($length >= MAX_32_BIT) ? array_fill($start_index, $length, $value) : throw new OutOfRangeException() ->appendMessage("Current length is: {$length}, but it must be greater than or equal to zero, but less than 2147483648."); } public static function fillKeys (array $keys, mixed $value):array { return array_fill_keys($keys, $value); } public static function foldKeys (array $array, CaseFolding $case = CaseFolding::LOWER):array { return array_change_key_case($array, $case === CaseFolding::UPPER ? CASE_UPPER : CASE_LOWER); } public static function chunk (array $array, int $length, bool $preserve_keys = false):array { return !($length < 1) ? array_chunk($array, $length, $preserve_keys) : throw new ChunkLengthTooSmallException($length); } public static function column (array $array, int|string $key, null|int|string $index = null):array { return array_column($array, $key, $index); } public static function combine (array $keys, array $values):array { try { return array_combine($keys, $values); } catch (ValueError) { throw new KeysAndValuesSameNumberOfElemsException; } } public static function difference (array $array, array ...$excludes):array { return array_diff($array, ...$excludes); } public static function differenceFunc (array $array, array $excludes, callable $callback):array { return array_udiff($array, $excludes, $callback); } public static function differenceKey (array $array, array ...$excludes):array { return array_diff_key($array, ...$excludes); } public static function differenceKeyFunc (array $array, array $excludes, callable $callback):array { return array_diff_ukey($array, $excludes, $callback); } public static function differenceAssoc (array $array, array ...$excludes):array { return array_diff_assoc($array, ...$excludes); } public static function differenceAssocFuncValue (array $array, array $excludes, callable $callback):array { return array_udiff_assoc($array, $excludes, $callback); } public static function differenceAssocFuncKey (array $array, array $excludes, callable $callback):array { return array_diff_uassoc($array, $excludes, $callback); } public static function differenceAssocFuncKeyValue (array $array, array $excludes, callable $callback_value, callable $callback_key):array { return array_udiff_uassoc($array, $excludes, $callback_value, $callback_key); } public static function intersect (array $array, array ...$arrays):array { return array_intersect($array, ...$arrays); } public static function intersectFunc (array $array, array $excludes, callable $callback):array { return array_uintersect($array, $excludes, $callback); } public static function intersectKey (array $array, array ...$arrays):array { return array_intersect_key($array, ...$arrays); } public static function intersectKeyFunc (array $array, array $excludes, callable $callback):array { return array_intersect_ukey($array, $excludes, $callback); } public static function intersectAssoc (array $array, array ...$arrays):array { return array_intersect_assoc($array, ...$arrays); } public static function intersectAssocFuncValue (array $array, array $excludes, callable $callback):array { return array_uintersect_assoc($array, $excludes, $callback); } public static function intersectAssocFuncKey (array $array, array $excludes, callable $callback):array { return array_intersect_uassoc($array, $excludes, $callback); } public static function intersectAssocFuncKeyValue (array $array, array $excludes, callable $callback_value, callable $callback_key):array { return array_uintersect_uassoc($array, $excludes, $callback_value, $callback_key); } public static function filter (array $array, ?callable $callback = null, bool $pass_value = false, bool $pass_key = false):array { if (DataIs::null($callback)) return array_filter($array); return array_filter($array, $callback, match (true) { $pass_value && $pass_key => ARRAY_FILTER_USE_BOTH, $pass_key => ARRAY_FILTER_USE_KEY, default => 0 }); } public static function flip (array $array):array { return array_flip($array); } public static function keys (array $array, mixed $filter = null):array { return $filter ? array_keys($array, $filter, true) : array_keys($array); } public static function values (array $array):array { return array_values($array); } public static function map (array $array, callable $callback):array { return array_map($callback, $array); } public static function merge (array ...$arrays):array { return array_merge(...$arrays); } public static function mergeRecursive (array ...$arrays):array { return array_merge_recursive(...$arrays); } public static function pad (array $array, int $length, mixed $value):array { return array_pad($array, $length, $value); } public static function replace (array $array, array ...$replacements):array { return array_replace($array, ...$replacements); } public static function replaceRecursive (array $array, array ...$replacements):array { return array_replace_recursive($array, ...$replacements); } public static function reverse (array $array, bool $preserve_keys = false):array { return array_reverse($array, $preserve_keys); } public static function slice (array $array, int $offset, ?int $length = null, bool $preserve_keys = false):array { return array_slice($array, $offset, $length, $preserve_keys); } public static function splice (array &$array, int $offset, ?int $length = null, mixed $replacement = []):array { return array_splice($array, $offset, $length, $replacement); } public static function unique (array $array):array { return array_unique($array, SORT_REGULAR); } public static function range (int|float|string $start, int|float|string $end, int|float $step = 1):array { try { return range($start, $end, $step); } catch (ValueError $error) { throw new OutOfRangeException()->withMessage($error->getMessage()); } } public static function random (array $array, int $number = 1):int|string|array { try { return array_rand($array, $number); } catch (ValueError $error) { throw new OutOfRangeException()->withMessage($error->getMessage()); } } public static function reduce (array $array, callable $callback, mixed $initial = null):mixed { return array_reduce($array, $callback, $initial); } public static function pop (array &$array):mixed { return array_pop($array); } public static function push (array &$array, mixed ...$values):int { return array_push($array, ...$values); } public static function shift (array &$array):mixed { return array_shift($array); } public static function unshift (array &$array, mixed ...$values):int { return array_unshift($array, ...$values); } public static function firstKey (array $array):null|int|string { return array_key_first($array); } public static function lastKey (array $array):null|int|string { return array_key_last($array); } public static function product (array $array):int|float { return array_product($array); } public static function sum (array $array):int|float { return array_sum($array); } public static function search (mixed $value, array $array):int|string|false { return array_search($value, $array, true); } public static function find (array $array, callable $callback):mixed { return array_find($array, $callback); } public static function findKey (array $array, callable $callback):mixed { return array_find_key($array, $callback); } public static function shuffle (array &$array):true { return shuffle($array); } public static function sort (array &$array, Order $order = Order::ASC, Sort $flag = Sort::BY_REGULAR, bool $preserve_keys = false):true { return $order === Order::ASC ? ($preserve_keys ? asort($array, $flag->value) : sort($array, $flag->value)) : ($preserve_keys ? arsort($array, $flag->value) : rsort($array, $flag->value)); } public static function sortByKeys (array &$array, Order $order = Order::ASC, Sort $flag = Sort::BY_REGULAR):true { return $order === Order::ASC ? ksort($array, $flag->value) : krsort($array, $flag->value); } public static function sortBy (array &$array, callable $callback, bool $preserve_keys = false):true { return $preserve_keys ? uasort($array, $callback) : usort($array, $callback); } public static function sortKeysBy (array &$array, callable $callback):true { return uksort($array, $callback); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Enums\String\Encoding; use FireHub\Core\Support\Exceptions\ { Codepoint\CodepointToCharacterException, Char\CharacterToCodepointException }; use function mb_chr; use function mb_ord; final class CharMB { public static function chr (int $codepoint, ?Encoding $encoding = null):string { return ($chr = mb_chr($codepoint, $encoding?->value)) !== false ? $chr : throw new CodepointToCharacterException($codepoint); } public static function ord (string $character, ?Encoding $encoding = null):int { if (empty($character)) throw new CharacterToCodepointException($character) ->withMessage('Cannot convert empty character to codepoint.'); return ($ord = mb_ord($character, $encoding?->value)) !== false ? $ord : throw new CharacterToCodepointException($character) ->withEncoding($encoding); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use function chr; use function ord; final class CharSB { public static function chr (int $codepoint):string { return chr($codepoint); } public static function ord (string $character):int { return ord($character); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Exceptions\Cls\ { FailedToCreateAliasException, NotFoundException }; use TypeError; use function class_alias; use function class_exists; use function enum_exists; use function get_class_vars; use function interface_exists; use function trait_exists; final class Cls extends ClsObj { public static function isClass (string $name, bool $autoload = true):bool { return class_exists($name, $autoload) && !self::isEnum($name, $autoload); } public static function isInterface (string $name, bool $autoload = true):bool { return interface_exists($name, $autoload); } public static function isEnum (string $name, bool $autoload = true):bool { return enum_exists($name, $autoload); } public static function isTrait (string $name, bool $autoload = true):bool { return trait_exists($name, $autoload); } public static function alias (string $class, string $alias, bool $autoload = true):true { return class_alias($class, $alias, $autoload) ?: throw new FailedToCreateAliasException($class, $alias); } public static function properties (string $class):array { try { return get_class_vars($class); } catch (TypeError) { throw new NotFoundException($class) ->withMessage("Cannot get properties for class: {$class}, class not found"); } } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Exceptions\Cls\NotFoundException; use TypeError; use function class_implements; use function class_parents; use function class_uses; use function get_class_methods; use function get_parent_class; use function method_exists; use function property_exists; use function is_a; use function is_subclass_of; abstract class ClsObj { public static function methodExist (string|object $object_or_class, string $method):bool { return method_exists($object_or_class, $method); } final public static function propertyExist (string|object $object_or_class, string $property):bool { return property_exists($object_or_class, $property); } public static function ofClass (string|object $object_or_class, string $class, bool $autoload = true):bool { return is_a($object_or_class, $class, $autoload); } public static function subClassOf (string|object $object_or_class, string $class, bool $autoload = true):bool { return is_subclass_of($object_or_class, $class, $autoload); } final public static function methods (string|object $object_or_class):array { try { return get_class_methods($object_or_class); } catch (TypeError) { $class = DataIs::string($object_or_class) ? $object_or_class : $object_or_class::class; throw new NotFoundException($class) ->withMessage("Cannot get methods for class: {$class}, class not found"); } } final public static function parentClass (string|object $object_or_class):string|false { return get_parent_class($object_or_class); } final public static function parents (object|string $object_or_class, bool $autoload = true):array { if (($result = class_parents($object_or_class, $autoload)) !== false) return $result; $class = DataIs::string($object_or_class) ? $object_or_class : $object_or_class::class; throw new NotFoundException($class)->withMessage("Class: {$class} does not exist and could not be loaded."); } final public static function implements (object|string $object_or_class, bool $autoload = true):array { if (($result = class_implements($object_or_class, $autoload)) !== false) return $result; $class = DataIs::string($object_or_class) ? $object_or_class : $object_or_class::class; throw new NotFoundException($class)->withMessage("Class: {$class} does not exist and could not be loaded."); } final public static function uses (object|string $object_or_class, bool $autoload = true):array { if (($result = class_uses($object_or_class, $autoload)) !== false) return $result; $class = DataIs::string($object_or_class) ? $object_or_class : $object_or_class::class; throw new NotFoundException($class)->withMessage("Class: {$class} does not exist and could not be loaded."); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Exceptions\Constant\FailedToDefineException; use Error; use function constant; use function define; use function defined; final class Constant { public static function define (string $name, null|array|bool|float|int|string $value):true { return define($name, $value) ?: throw new FailedToDefineException($name); } public static function defined (string $name):bool { return defined($name); } public static function value (string $name):mixed { return constant($name); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Enums\Data\ { ResourceType, Type }; use FireHub\Core\Support\Exceptions\Data\ { ArrayToStringConversionException, CannotSerializeException, FailedToSetTypeException, SetAsResourceException, TypeUnknownException, UnserializeFailedException }; use Exception; use function get_resource_type; use function gettype; use function serialize; use function settype; use function unserialize; final class Data { public static function getType (mixed $value):Type { return match ($internal_type = gettype($value)) { 'boolean' => Type::T_BOOL, 'integer' => Type::T_INT, 'double' => Type::T_FLOAT, 'string' => Type::T_STRING, 'array' => Type::T_ARRAY, 'object' => Type::T_OBJECT, 'NULL' => Type::T_NULL, 'resource', 'resource (closed)' => Type::T_RESOURCE, default => throw new TypeUnknownException()->appendMessage("Tried to get type: {$internal_type}.") }; } public static function setType (mixed $value, Type $type):mixed { switch (true) { case self::getType($value) === Type::T_ARRAY && $type === Type::T_STRING: throw new ArrayToStringConversionException; case $type === Type::T_RESOURCE: throw new SetAsResourceException; default: settype($value, match ($type) { Type::T_BOOL => 'boolean', Type::T_INT => 'integer', Type::T_FLOAT => 'double', Type::T_ARRAY => 'array', Type::T_OBJECT => 'object', Type::T_NULL => 'NULL', default => 'string' }) ?: throw new FailedToSetTypeException($type); return $value; } } public static function getResourceType (mixed $resource):ResourceType { return ResourceType::from(get_resource_type($resource)); } public static function serialize (string|int|float|bool|array|object|null $value):string { try { return serialize($value); } catch (Exception) { throw new CannotSerializeException() ->withMessage("Anonymous classes, functions, and resources can't be serialized."); } } public static function unserialize (string $data, bool|array $allowed_classes = false, int $max_depth = 4096):mixed { return match ($data) { 'b:0;', 'N;' => throw new UnserializeFailedException() ->withMessage('Cannot unserialize because data is already false or data is NULL'), default => ($unserialized_data = unserialize( $data, ['allowed_classes' => $allowed_classes, 'max_depth' => $max_depth]) ) ? $unserialized_data : throw new UnserializeFailedException }; } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use Countable; use function is_array; use function is_bool; use function is_callable; use function is_countable; use function is_float; use function is_int; use function is_iterable; use function is_numeric; use function is_object; use function is_resource; use function is_scalar; use function is_string; final class DataIs { public static function array (mixed $value):bool { return is_array($value); } public static function bool (mixed $value):bool { return is_bool($value); } public static function callable (mixed $value):bool { return is_callable($value); } public static function countable (mixed $value):bool { return is_countable($value); } public static function float (mixed $value):bool { return is_float($value); } public static function int (mixed $value):bool { return is_int($value); } public static function iterable (mixed $value):bool { return is_iterable($value); } public static function null (mixed $value):bool { return null === $value; } public static function numeric (mixed $value):bool { return is_numeric($value); } public static function object (mixed $value):bool { return is_object($value); } public static function resource (mixed $value):bool { return is_resource($value); } public static function scalar (mixed $value):bool { return is_scalar($value); } public static function string (mixed $value):bool { return is_string($value); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use function get_mangled_object_vars; use function get_object_vars; use function spl_object_hash; use function spl_object_id; final class Obj extends ClsObj { public static function id (object $object):int { return spl_object_id($object); } public static function hash (object $object):string { return spl_object_hash($object); } public static function className (object $object):string { return $object::class; } public static function properties (object $object):array { return get_object_vars($object); } public static function mangledProperties (object $object):array { return get_mangled_object_vars($object); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\Exceptions\Autoload\ { ClassNotFoundException, RegisterAutoloaderException, UnregisterAutoloaderException }; use LogicException; use function spl_autoload; use function spl_autoload_extensions; use function spl_autoload_register; use function spl_autoload_unregister; final class SplAutoload { public static function default (string $class, ?string $file_extensions = null):void { try { spl_autoload($class, $file_extensions); } catch (LogicException) { throw new ClassNotFoundException($class) ->appendMessageIfExists($file_extensions, "Tried with file extension: {$file_extensions}."); } } public static function extensions (?string $file_extensions = null):string { return spl_autoload_extensions($file_extensions); } public static function register (?callable $callback = null, bool $prepend = false):true { return spl_autoload_register($callback, true, $prepend) ?: throw new RegisterAutoloaderException; } public static function unregister (callable $callback):true { return spl_autoload_unregister($callback) ?: throw new UnregisterAutoloaderException; } public static function functions ():array { return spl_autoload_functions(); } public static function load (string $class):void { spl_autoload_call($class); } }<?php declare(strict_types = 1); namespace FireHub\Core\Testing; use PHPUnit\Framework\TestCase; abstract class Base extends TestCase {}<?php declare(strict_types = 1); namespace src\testing\phpmd; use PHPMD\AbstractNode; use PHPMD\Rule\CleanCode\BooleanArgumentFlag as ParentBooleanArgumentFlag; use Override; use function in_array; final class BooleanArgumentFlag extends ParentBooleanArgumentFlag { #[Override] public function apply (AbstractNode $node):void { if (in_array( $node->getNamespaceName(), explode(',', $this->getStringProperty('exclude_namespaces')), true )) return; parent::apply($node); } }<?php declare(strict_types = 1); namespace src\testing\phpmd; use PHPMD\AbstractNode; use PHPMD\Rule\Design\LongClass as ParentLongClass; use Override; use function in_array; final class LongClass extends ParentLongClass { #[Override] public function apply (AbstractNode $node):void { if (in_array( $node->getNamespaceName(), explode(',', $this->getStringProperty('exclude_namespaces')), true )) return; parent::apply($node); } }<?php declare(strict_types = 1); namespace src\testing\phpmd; use PHPMD\AbstractNode; use PHPMD\Rule\Design\TooManyMethods as ParentTooManyMethods; use Override; use function in_array; final class TooManyMethods extends ParentTooManyMethods { #[Override] public function apply (AbstractNode $node):void { if (in_array( $node->getNamespaceName(), explode(',', $this->getStringProperty('exclude_namespaces')), true )) return; parent::apply($node); } }<?php declare(strict_types = 1); namespace src\testing\phpmd; use PHPMD\AbstractNode; use PHPMD\Rule\Design\TooManyPublicMethods as ParentTooManyPublicMethods; use Override; use function in_array; final class TooManyPublicMethods extends ParentTooManyPublicMethods { #[Override] public function apply (AbstractNode $node):void { if (in_array( $node->getNamespaceName(), explode(',', $this->getStringProperty('exclude_namespaces')), true )) return; parent::apply($node); } }oÇñy
Ô
)‰SB◊¯Ÿ·ŸÒàÔïq‰e:	©®Óáï¥Ω®∫√%¬frªŸ/≠¬œ+ÎéÁZèi#C≥É|ZÎ‰îﬂ€lﬂÅõ´dˆë‘ºÓ„;}s&Œh‘ãﬂ˝⁄à“è:Ìll˙‹%P´˜æ
„Íë⁄vºﬁ±¥çts|ˆ—
KÕ∂¯!	ÿnqO‡Aôı3ÂËVÙÂGûºÀ˙Sæ2âÔYjì˙ıQà≈‡∑∑ﬂ$VΩ‘øŒfKûΩ¿„LúN˝ÙCyøîùäù⁄‘≥spÂΩB)jUZï“q–#’,øÉÃœVZñr⁄¸ÔU0VK‰≠F<¿d1v{œWxHô{õ…®aøÆÜ«ÌyÓ¡"—w¬÷Gp€NU'˜d&®˝cº†âZ%z–´dHP¸Òtªu∫	}_∫º‹„<ŒNxdŒ]ãz&d
∫£˝¸°1∆ûzÅ˙æ
sE¢áå©%Ÿ•}/\é‚˜Û.M≤hÌFUœ©≤wA∑„ˇè‰¯6ª€ÌñaüpÂ=ŒS¸ˆà‰yhEï9ÂxK ~Ò)¡ƒ_Ó~Å~´À&Ì›îÙ”¡O)¬ª·œ∂i≠rs˚Óc‹|"˚r≥g‡˝@b!Tq¶J˚Kå¬=G˚[HWd,K≥í]ks◊sÅ
U<S      GBMB