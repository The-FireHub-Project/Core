<?php

$web = '/public/index.php';

if (\in_array('phar', stream_get_wrappers()) && class_exists(\Phar::class, 0)) {
    \Phar::interceptFileFuncs();
    set_include_path('phar://'.__FILE__.\PATH_SEPARATOR.get_include_path());
    \Phar::webPhar(null, $web);

    include 'phar://'.__FILE__.'/'.\Extract_Phar::START;

    return;
}

if ((isset($_SERVER['REQUEST_URI'], $_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {
    \Extract_Phar::go(true);
    $mimes = [
        'phps' => 2,
        'c' => 'text/plain',
        'cc' => 'text/plain',
        'cpp' => 'text/plain',
        'c++' => 'text/plain',
        'dtd' => 'text/plain',
        'h' => 'text/plain',
        'log' => 'text/plain',
        'rng' => 'text/plain',
        'txt' => 'text/plain',
        'xsd' => 'text/plain',
        'php' => 1,
        'inc' => 1,
        'avi' => 'video/avi',
        'bmp' => 'image/bmp',
        'css' => 'text/css',
        'gif' => 'image/gif',
        'htm' => 'text/html',
        'html' => 'text/html',
        'htmls' => 'text/html',
        'ico' => 'image/x-ico',
        'jpe' => 'image/jpeg',
        'jpg' => 'image/jpeg',
        'jpeg' => 'image/jpeg',
        'js' => 'application/x-javascript',
        'midi' => 'audio/midi',
        'mid' => 'audio/midi',
        'mod' => 'audio/mod',
        'mov' => 'movie/quicktime',
        'mp3' => 'audio/mp3',
        'mpg' => 'video/mpeg',
        'mpeg' => 'video/mpeg',
        'pdf' => 'application/pdf',
        'png' => 'image/png',
        'swf' => 'application/shockwave-flash',
        'tif' => 'image/tiff',
        'tiff' => 'image/tiff',
        'wav' => 'audio/wav',
        'xbm' => 'image/xbm',
        'xml' => 'text/xml',
    ];

    header('Cache-Control: no-cache, must-revalidate');
    header('Pragma: no-cache');

    $basename = basename(__FILE__);

    if (!strpos($_SERVER['REQUEST_URI'], $basename)) {
        chdir(\Extract_Phar::$temp);

        include $web;

        return;
    }
    $pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + \strlen($basename));

    if (!$pt || $pt == '/') {
        $pt = $web;
        header('HTTP/1.1 301 Moved Permanently');
        header('Location: '.$_SERVER['REQUEST_URI'].'/'.$pt);

        exit;
    }
    $a = realpath(\Extract_Phar::$temp.\DIRECTORY_SEPARATOR.$pt);

    if (!$a || \strlen(\dirname($a)) < \strlen(\Extract_Phar::$temp)) {
        header('HTTP/1.0 404 Not Found');
        echo "<html>\n <head>\n  <title>File Not Found<title>\n </head>\n <body>\n  <h1>404 - File Not Found</h1>\n </body>\n</html>";

        exit;
    }
    $b = pathinfo($a);

    if (!isset($b['extension'])) {
        header('Content-Type: text/plain');
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }

    if (isset($mimes[$b['extension']])) {
        if ($mimes[$b['extension']] === 1) {
            include $a;

            exit;
        }

        if ($mimes[$b['extension']] === 2) {
            highlight_file($a);

            exit;
        }
        header('Content-Type: '.$mimes[$b['extension']]);
        header('Content-Length: '.filesize($a));
        readfile($a);

        exit;
    }
}

final class Extract_Phar {
    public const GZ = 0x10_00;
    public const BZ2 = 0x20_00;
    public const MASK = 0x30_00;
    public const START = '/public/console.php';
    public const LEN = 6_661;
    public static $temp;
    public static $origdir;

    public static function go($return = false): void {
        $fp = fopen(__FILE__, 'rb');
        fseek($fp, self::LEN);
        $L = unpack('V', $a = fread($fp, 4));
        $m = '';

        do {
            $read = 8_192;

            if ($L[1] - \strlen($m) < 8_192) {
                $read = $L[1] - \strlen($m);
            }
            $last = fread($fp, $read);
            $m .= $last;
        } while (\strlen($last) && \strlen($m) < $L[1]);

        if (\strlen($m) < $L[1]) {
            exit('ERROR: manifest length read was "'
            .\strlen($m).'" should be "'
            .$L[1].'"');
        }

        $info = self::_unpack($m);
        $f = $info['c'];

        if ($f & self::GZ) {
            if (!\function_exists('gzinflate')) {
                exit('Error: zlib extension is not enabled -'
                .' gzinflate() function needed for zlib-compressed .phars');
            }
        }

        if ($f & self::BZ2) {
            if (!\function_exists('bzdecompress')) {
                exit('Error: bzip2 extension is not enabled -'
                .' bzdecompress() function needed for bz2-compressed .phars');
            }
        }

        $temp = self::tmpdir();

        if (!$temp || !is_writable($temp)) {
            $sessionpath = session_save_path();

            if (str_contains($sessionpath, ';'))
                $sessionpath = substr($sessionpath, strpos($sessionpath, ';') + 1);

            if (!file_exists($sessionpath) || !is_dir($sessionpath)) {
                exit('Could not locate temporary directory to extract phar');
            }
            $temp = $sessionpath;
        }

        $temp .= '/pharextract/'.basename(__FILE__, '.phar');
        self::$temp = $temp;
        self::$origdir = getcwd();
        mkdir($temp, 0o777, true);
        $temp = realpath($temp);

        if (!file_exists($temp.\DIRECTORY_SEPARATOR.md5_file(__FILE__))) {
            self::_removeTmpFiles($temp, getcwd());
            mkdir($temp, 0o777, true);
            file_put_contents($temp.'/'.md5_file(__FILE__), '');

            foreach ($info['m'] as $path => $file) {
                $a = !file_exists(\dirname($temp.'/'.$path));
                mkdir(\dirname($temp.'/'.$path), 0o777, true);
                clearstatcache();

                if ($path[\strlen($path) - 1] == '/') {
                    mkdir($temp.'/'.$path, 0o777);
                } else {
                    file_put_contents($temp.'/'.$path, self::extractFile($path, $file, $fp));
                    chmod($temp.'/'.$path, 0o666);
                }
            }
        }

        chdir($temp);

        if (!$return) {
            include self::START;
        }
    }

    public static function tmpdir() {
        if (str_contains(\PHP_OS, 'WIN')) {
            if ($var = getenv('TMP') ?: getenv('TEMP')) {
                return $var;
            }

            if (is_dir('/temp') || mkdir('/temp')) {
                return realpath('/temp');
            }

            return false;
        }

        if ($var = getenv('TMPDIR')) {
            return $var;
        }

        return realpath('/tmp');
    }

    public static function _unpack($m) {
        $info = unpack('V', substr($m, 0, 4));
        $l = unpack('V', substr($m, 10, 4));
        $m = substr($m, 14 + $l[1]);
        $s = unpack('V', substr($m, 0, 4));
        $o = 0;
        $start = 4 + $s[1];
        $ret['c'] = 0;

        for ($i = 0; $i < $info[1]; $i++) {
            $len = unpack('V', substr($m, $start, 4));
            $start += 4;
            $savepath = substr($m, $start, $len[1]);
            $start += $len[1];
            $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));
            $ret['m'][$savepath][3] = \sprintf('%u', $ret['m'][$savepath][3]
            & 0xFF_FF_FF_FF);
            $ret['m'][$savepath][7] = $o;
            $o += $ret['m'][$savepath][2];
            $start += 24 + $ret['m'][$savepath][5];
            $ret['c'] |= $ret['m'][$savepath][4] & self::MASK;
        }

        return $ret;
    }

    public static function extractFile($path, $entry, $fp) {
        $data = '';
        $c = $entry[2];

        while ($c) {
            if ($c < 8_192) {
                $data .= fread($fp, $c);
                $c = 0;
            } else {
                $c -= 8_192;
                $data .= fread($fp, 8_192);
            }
        }

        if ($entry[4] & self::GZ) {
            $data = gzinflate($data);
        } elseif ($entry[4] & self::BZ2) {
            $data = bzdecompress($data);
        }

        if (\strlen($data) != $entry[0]) {
            exit('Invalid internal .phar file (size error '.\strlen($data).' != '
            .$stat[7].')');
        }

        if ($entry[3] != \sprintf('%u', crc32($data) & 0xFF_FF_FF_FF)) {
            exit('Invalid internal .phar file (checksum error)');
        }

        return $data;
    }

    public static function _removeTmpFiles($temp, $origdir): void {
        chdir($temp);

        foreach (glob('*') as $f) {
            if (file_exists($f)) {
                is_dir($f) ? rmdir($f) : unlink($f);

                if (file_exists($f) && is_dir($f)) {
                    self::_removeTmpFiles($f, getcwd());
                }
            }
        }

        rmdir($temp);
        clearstatcache();
        chdir($origdir);
    }
}

\Extract_Phar::go();
__HALT_COMPILER(); ?>
  
           7   a:2:{s:4:"name";s:4:"core";s:7:"version";s:6:"v0.1.2";}&   components/error/firehub.Exception.phpö   c
7gö   ƒî¬[∂      '   components/error/firehub.Exception.php~
   c
7g
   à-Óî∂         public/console.php!   c
7g!   ∑,MŒ∂         public/index.php!   c
7g!   ∑,MŒ∂      9   support/lowlevel/exceptions/firehub.AutoloadException.phpÆ   c
7gÆ   Äqœ
∂      :   support/lowlevel/exceptions/firehub.AutoloadException.php~Ä   c
7gÄ   Çæf
∂      A   support/lowlevel/exceptions/firehub.AutoloadRegisterException.phpë   c
7gë   ˚Ÿc&∂      B   support/lowlevel/exceptions/firehub.AutoloadRegisterException.php~†   c
7g†   ¶„˛J∂      >   support/lowlevel/exceptions/firehub.ClassNotFoundException.phpé   c
7gé   M-∂      ?   support/lowlevel/exceptions/firehub.ClassNotFoundException.php~î   c
7gî   `±óŒ∂      (   support/lowlevel/firehub.SplAutoload.phpG  c
7gG  á®î2∂      )   support/lowlevel/firehub.SplAutoload.php~G  c
7gG  á®î2∂      %   testing/phpmd/BooleanArgumentFlag.php™  c
7g™  ï—Ä∂      7<?php declare(strict_types = 1); namespace FireHub\Core\Components\Error; use Exception as InternalException; class Exception extends InternalException {}<?php declare(strict_types = 1); namespace FireHub\Core\Components\Error; use Exception; class AutoloadException extends Exception {}<?php declare(strict_types = 1); <?php declare(strict_types = 1); <?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exceptions; use FireHub\Core\Components\Error\Exception; class AutoloadException extends Exception {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exception; class AutoloadException extends Exception {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exceptions; class AutoloadRegisterException extends AutoloadException {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exceptions; use Exception; class AutoloadRegisterException extends AutoloadException {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exceptions; class ClassNotFoundException extends AutoloadException {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel\Exceptions; final class ClassNotFoundException extends AutoloadException {}<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\LowLevel\Exceptions\ { AutoloadRegisterException, ClassNotFoundException }; use LogicException; use function spl_autoload; use function spl_autoload_extensions; use function spl_autoload_register; use function spl_autoload_unregister; final class SplAutoload { public static function default (string $class, ?string $file_extensions = null):void { try { spl_autoload($class, $file_extensions); } catch (LogicException) { throw new ClassNotFoundException('Failed to register a callback function as an autoloader.'); } } public static function extensions (?string $file_extensions = null):string { return spl_autoload_extensions($file_extensions); } public static function register (?callable $callback = null, bool $prepend = false):true { return spl_autoload_register($callback, true, $prepend) ?: throw new AutoloadRegisterException('Failed to register a callback function as an autoloader.'); } public static function unregister (callable $callback):true { return spl_autoload_unregister($callback) ?: throw new AutoloadRegisterException('Failed to unregister autoload implementation.'); } public static function functions ():array { return spl_autoload_functions(); } public static function load (string $class):void { spl_autoload_call($class); } }<?php declare(strict_types = 1); namespace FireHub\Core\Support\LowLevel; use FireHub\Core\Support\LowLevel\Exceptions\ { AutoloadRegisterException, ClassNotFoundException }; use LogicException; use function spl_autoload; use function spl_autoload_extensions; use function spl_autoload_register; use function spl_autoload_unregister; final class SplAutoload { public static function default (string $class, ?string $file_extensions = null):void { try { spl_autoload($class, $file_extensions); } catch (LogicException) { throw new ClassNotFoundException('Failed to register a callback function as an autoloader.'); } } public static function extensions (?string $file_extensions = null):string { return spl_autoload_extensions($file_extensions); } public static function register (?callable $callback = null, bool $prepend = false):true { return spl_autoload_register($callback, true, $prepend) ?: throw new AutoloadRegisterException('Failed to register a callback function as an autoloader.'); } public static function unregister (callable $callback):true { return spl_autoload_unregister($callback) ?: throw new AutoloadRegisterException('Failed to unregister autoload implementation.'); } public static function functions ():array { return spl_autoload_functions(); } public static function load (string $class):void { spl_autoload_call($class); } }<?php declare(strict_types = 1); use PHPMD\AbstractNode; use PHPMD\Rule\CleanCode\BooleanArgumentFlag as ParentBooleanArgumentFlag; final class src_testing_phpmd_BooleanArgumentFlag extends ParentBooleanArgumentFlag { #[\Override] public function apply (AbstractNode $node):void { if (\in_array( $node->getNamespaceName(), explode(',', $this->getStringProperty('exclude_namespaces')), true )) return; parent::apply($node); } }⁄æùE∏ Ú]gı
–Ë79Ç	?û≥∆x(ô&
I“Êû›V#,å≈|<
ÌÅÿÚã6≤dóó
π:ØÜ_Ë≈B_ƒ`=f\ÊZLñΩ#¶Ü.œƒgqëôïœ°Bøô§á}ãKu
◊Jxu,ûÕz@≤∆Hvr„ëñqŒÑÜ
xG÷m-†¥cX≠÷q>™3I≠é◊¸¡Cä.„@ _dØˇµN
”Å]r≥å¡‚‹øç{çö 4>E/
àËP
¬›ç}u˛l¢K®⁄Cø.EàÄﬂFŒÈ]5µÑ0, [¥¡¢Èäª |+ Ÿµª;ß$Ésò¥
¯á"‹îMÒS:ë*`,k*û=
¥œSGF
çu–cÑ¨†qm>çGi-Xdá_n!0€ÅÊüÓFzü√4Gnaò„©¢HD)GZ∂Ò≥Fô·º¶⁄yü†®›hè|hàMÜ›+Úß[‡∂8	Ç†ÍÈyã·o≠Ì#©#"Æˆ4ÿ
≥€&üù÷
Ω®QTFÑâ±˙ÄﬁO\uÃRU«h097oÃë,∞ö´Z`ï¡aR˘0Üˆ5Fg¯wï(1∫Á«•>	»he
-ú4öfÅ¶3õ"J8©ej∫Y„‘X›9_~t"†"(pkÄ?B®É'$U	‡4∏ó;6˜5À Âgt˚√i&       GBMB